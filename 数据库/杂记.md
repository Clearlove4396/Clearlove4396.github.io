##### 意向锁

1. **产生背景**

   1.1 多粒度封锁协议

   ​	允许多粒度树中的每个结点被独立地加锁。**对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁**。因此，一个数据对象可能以两种方式封锁：显示封锁和隐式封锁。

   - **显式封锁**：应事务的要求**直接**加到对象上的锁。

   - **隐式封锁**：数据对象没有被独立的加锁，是由于其**上级结点加锁**而使该数据对象加上了锁。

     ![image-20200905212649985](.\pictures\三级粒度树.png)

   1.2 为什么使用**意向锁**？

   ​	一般地，对某个数据对象加锁，系统要做以下事情：① 检查该数据对象上有无显式封锁与之冲突；② 检查其所有上级结点，看本事务的显示封锁是否与该数据对象上的隐式封锁（即由于上级结点已加的封锁造成）冲突；③ 还要检查其所有下级结点，看它们的显式封锁是否与本事务的隐式封锁（将要加到下级结点的封锁）冲突。显然这些检查将使得加锁效率变低。

2. **意向锁**

   - 有了意向锁，数据库管理系统就无须逐个检查下一级结点的显式封锁。
   - 定义：**如果对结点加意向锁，则说明该结点的下层结点正在被加锁**；**对任意一个结点加锁时，必须先对它的上层结点加意向锁**。申请封锁时应该**按自上而下**的次序进行（这样就解决了问题②），释放封锁时则应该按照自下而上的次序进行。

   **2.1 三种意向锁**

   - IS锁：意向共享锁

     - 如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。比如，事务T1要对R1中的某个元组加S锁，则要求对关系R1和数据库加IS锁。

   - IX锁：意向排他锁

     - 同上

   - SIX锁：共享意向排他锁

     - 如果对一个数据对象加SIX锁，表示对它加S锁，在加IX锁，即SIX = S + IX。例如对某个表加SIX锁，表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁）。

     
     
     
     
     # 应用场景
     
     在innodb的使用场景中，里面有实现了行锁，具体有对行的读锁，写锁。另外，如果对一个表作一些统一的操作，表的层面，有表层级的读锁，写锁。那这个意向锁是干嘛用的？
     
     我们假设一个场景，一个事务A正在写某个表T的第r行加了写锁，另一个事务B尝试去对整个表做操作（例如修改表结构的时候），B尝试去对整个表加一个写锁。则此时，需要执行两个步骤：
     1）检查表T是否被上了读锁或者写锁。
     2）遍历所有行，查看每一行是否被上了读锁或写锁。
     步骤1可以很快执行，但是步骤2，则需要非常耗时，效率低下。此时，**意向锁**出场了
     
     # 使用逻辑
     
     意向锁的作用，相当于就是在低层次资源是否使用，加了一个tag来标识而已。对于步骤2的执行可以大大加速，仅此而已。
     有了意向锁之后，事务A的操作步骤如下：
     1）事务A上行锁时，先对表上一个写意向锁。
     2）事务A对r行上一个写锁。
     
     事务B想对表上写锁，操作步骤如下：
     1）检查表T是否被上了读锁或写锁。
     2）检查表是否被上了意向锁（因为所有行的读写之前，会先上意向锁），即可判断表中是否有任何一行被上了读锁或写锁。
     步骤2在检查逻辑的时间复杂度，由于增加了意向锁之后，时间复杂度由O(n)，提升到了O(1)，效率大幅提升。另外，从这个逻辑来看，读和写的意向锁，两者是彼此兼容，当时读到这他们之间的兼容关系的时候，一直不太理解，没理解到点上。
     
     # 总结
     
     意向锁的设计目的，只是为了方便上层资源检查下层资源是否有被占用的加速设计，本身并不能增加并发度。
     从意向锁的设计思路来看，我们在系统对层次资源的并发使用的时候，也是可以参数意向锁的设计思路，做到触类旁通，真正提升技术方案的理解水平！
     
     

