##### 意向锁

1. **产生背景**

   1.1 多粒度封锁协议

   ​	允许多粒度树中的每个结点被独立地加锁。**对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁**。因此，一个数据对象可能以两种方式封锁：显示封锁和隐式封锁。

   - **显式封锁**：应事务的要求**直接**加到对象上的锁。

   - **隐式封锁**：数据对象没有被独立的加锁，是由于其**上级结点加锁**而使该数据对象加上了锁。

     ![image-20200905212649985](.\pictures\三级粒度树.png)

   1.2 为什么使用**意向锁**？

   ​	一般地，对某个数据对象加锁，系统要做一下事情：① 检查该数据对象上有无显式封锁与之冲突；② 检查其所有上级结点，看本事务的显示封锁是否与该数据对象上的隐式封锁（即由于上级结点已加的封锁造成）冲突；③ 还要检查其所有下级结点，看它们的显式封锁是否与本事务的隐式封锁（将要加到下级结点的封锁）冲突。显然这些检查将使得加锁效率变低。

2. **意向锁**

   - 有了意向锁，数据库管理系统就无须逐个检查下一级结点的显式封锁。
   - 定义：**如果对结点加意向锁，则说明该结点的下层结点正在被加锁**；**对任意一个结点加锁时，必须先对它的上层结点加意向锁**。申请封锁时应该**按自上而下**的次序进行（这样就解决了问题②），释放封锁时则应该按照自下而上的次序进行。

   **2.1 三种意向锁**

   - IS锁：意向共享锁

     - 如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。比如，事务T1要对R1中的某个元组加S锁，则要求对关系R1和数据库加IS锁。

   - IX锁：意向排他锁

     - 同上

   - SIX锁：共享意向排他锁

     - 如果对一个数据对象加SIX锁，表示对它加S锁，在加IX锁，即SIX = S + IX。例如对某个表加SIX锁，表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁）。

     

