---
typora-root-url: markdown-picture
---

## Http和Https

- HTTP：超文本传输协议，是一个基于请求与响应，无状态，应用层的协议，常基于TCP/IP协议栈

  - HTTP/1.0：不支持长连接，每次请求与响应都需要重新建立连接（TCP三次握手，四次挥手）
  - HTTP/1.1：支持**长连接**（即持久连接），节约带宽，管道机制
  - HTTP/2：支持**多路复用**、服务器推送（服务器可以主动向客户端推送消息）、头信息压缩。

- **长连接**（持久连接）：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

  - 早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。

  - 减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

    ![长连接与短链接](./长连接与短链接.jpg)

- **管道机制**

  - **客户端可通过同一个TCP连接同时发送多个请求**。如果客户端需要请求两个资源，以前的做法是在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求；而管道机制则允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。

- **多路复用**

  - HTTP1.1的缺点：
- **串行的文件传输**。虽然 HTTP 1.1 默认启用长TCP连接，但所有的请求-响应都是按序进行的(这里的长连接可理解成**半双工**协议。即便是HTTP 1.1引入了管道机制，也是如此)。复用同一个TCP连接期间，即便是通过管道同时发送了多个请求，服务端也是按请求的顺序依次给出响应的；而客户端在未收到之前所发出所有请求的响应之前，将会阻塞后面的请求(排队等待)，这称为"**队头堵塞**"（Head-of-line blocking）。
    - **连接数过多**。我们假设`Apache`设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。（也就是说HTTP1.1每请求一个文件就需要建立一个TCP连接）
  - HTTP2.0的改进：HTTP/2的长连接可以理解为**全双工**的连接
    - 解决问题一：在`HTTP1.1`的协议中，我们传输的`request`和`response`都是基本于文本的，这样就会引发一个问题：所有的数据必须按顺序传输，比如需要传输：`hello world`，只能从`h`到`d`一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在`HTTP1.1`是不能实现的。所以`HTTP/2`引入了**帧**的概念，**帧可以对数据进行顺序标识**，浏览器收到数据之后就可以对数据进行按序合并。
    - 解决问题二：`HTTP/2`对同一域名下所有请求都是基于**流**，也就是说同一域名不管访问多少文件，也只**建立一路连接**。
  
- 请求报文：

  - 请求行：请求方法、URL、协议/版本
  - 请求头
  - 请求正文

- 响应报文

  - 状态行：协议/版本、状态码、状态码简单说明
  - 响应头
  - 响应正文

- 常见请求方法

  - GET：请求指定的页面信息，并返回实体主体。一般没有请求正文
  - POST：向指定资源**提交**数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
  - HEAD：类似于get请求，只不过返回的响应报文中没有具体的内容，仅用于确定资源是否存在。
  - PUT：从客户端向服务器传送的数据**取代**指定的文档的内容。
  - DELETE：请求服务器删除指定的页面。

- **POST和GET的区别**

  - 都包含请求头和请求行，post多了请求正文。
  - get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。post用来提交，如把账号密码放入body中。
  - GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到。
  - GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。

- 常见状态码

  - 200 OK - 客户端请求成功
  - 301 - 永久重定向。资源（网页等）被永久转移到其它URL
  - 302 - 临时跳转
  - 400 Bad Request - 客户端请求有语法错误，不能被服务器所理解
  - 401 Unauthorized - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
  - 404 - 请求资源不存在，可能是输入了错误的URL
  - 500 - 服务器内部发生了不可预期的错误
  - 503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。

- GET 和 POST 方法都是**安全**和**幂等**的吗？

  - 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
  - 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

  - 那么很明显 **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。

  - **POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。

- HTTP的缺点

  - 通信使用明文（不加密），内容可能会被窃听。比如，账号密码容易泄露
  - 不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝等网站
  - 无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告

- HTTP和HTTPS的区别

  - HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
  - HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
  - HTTP 的端口号是 80，HTTPS 的端口号是 443。
  - HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

- HTTPS 是如何解决上面的三个风险的？

  - **混合加密**的方式实现信息的**机密性**，解决了窃听的风险。

  - **摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
  - 将服务器公钥放入到**数字证书**中，解决了冒充的风险。

- 混合加密

  - 在通信建立前采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
  - 在通信过程中全部使用**对称加密**的「会话秘钥」的方式加密明文数据。

  

  