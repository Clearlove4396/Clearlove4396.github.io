## 进程

1. 进程：程序在一组数据集合上的一次动态执行过程。所以一个程序运行了两遍，应该被看作两个进程。

2. **创建进程**（4个主要事件）

   - 系统初始化
     - 前台进程：同用户交互
     - 后台进程：又称守护进程
   - 执行了正在运行的进程所调用的进程创建系统调用
   - 用户请求创建一个新进程
   - 一个批处理作业的初始化：仅在大型机的批处理系统中应用

3. **fork()**

   - UNIX中唯一一个创建进程的系统调用。

   - 分两步：1）创建一个与调用进程相同的副本；2）子进程执行execve系统调用，修改其存储映像并运行一个新的程序。

   - > 为什么要分两步？

     > 答：为了在fork之后但execve之前允许该子进程处理其文件描述符，这样可以完成对标准输入、标准输出和标准出错的重定向。

     

#### 进程间通信

1. 三个问题

   - 进程如何把信息传递给另一个进程（同一个进程中的线程对于解决这个问题比较容易，因为它们有相同的地址空间）
   - 互斥：确保两个或更多的进程在关键活动（临界区）中不会出现交叉。（解决方法适用于线程）
   - 同步：进程之间按照正确的顺序执行。（解决方法适用于线程）

2. 互斥

   1. 忙等待的互斥

      - 屏蔽中断：进程在刚刚进入临界区的时候，立即屏蔽所有中断，并在就要离开之前再打开中断（CPU是通过中断（时钟中断和其他中断）实现进程切换的）

        > 缺点

        > 1. “屏蔽中断”这种权利交给了用户。
        > 2. 对于多CPU的系统失效，因为屏蔽中断只是disable一个CPU的中断，其他CPU上运行的进程仍然可以进入临界区。

      - Peterson算法

        ```c++
        // Pi进程
        interested[i] = true;
        turn = j;
        while(interested[j] && turn == j);
        //进入临界区
        interested[i] = false;
        ```

        ```c++
        // Pj进程
        interested[j] = true;
        turn = i;
        while(interested[i] && turn == i);
        //进入临界区
        interested[j] = false;
        ```

      - TSL指令：`TSL RX, LOCK`将一个内存字`LOCK`读到寄存器`RX`中，然后在该内存地址上存一个**非零值**。当操作结束时（从临界区退出时），进程用一条普通的`mov`指令将lock的值重新设置为0。执行TSL指令的CPU将锁住内存总线，以禁止其他CPU在本指令结束之前访问内存。

        ```assembly
        enter_region:
        	TSL REGISTER, LOCK
        	CMP REGISTER, #0
        	JNE enter_region
        	RET
        	
        leave_region:
        	MOVE LOCK, #0
        	RET
        ```

      - XCHG指令

        ```assembly
        enter_region:
        	MOVE REGISTER, #1
        	XCHG REGISTER, LOCK
        	CMP REGISTER, #0
        	JNE enter_region
        	RET
        	
        leave_region:
        	MOVE LOCK, #0
        	RET
        ```

      - 忙等待互斥可能导致的问题

        - 浪费CPU时间；
        - **优先级反转问题**：一台计算机有两个进程，H优先级高，L优先级低。调度规则规定：只要H处于就绪态它就可以运行。在某一时刻，L处于临界区中，此时H变到就绪态，准备运行。现在H开始忙等待，L得不到CPU资源，所以L无法从临界区中退出，H也将永远无法进入临界区。

3. 信号量

   - 使用一个整型变量来累计唤醒次数（资源的个数）

     ```c++
     down(s){
     	while(s <= 0);
     	s = s - 1;   //用掉一个保存的唤醒信号
     }
     ```

     ```c++
     up(s){
     	s = s + 1;
     }
     ```

4. 条件变量（记录型信号量）

   - 使用一个整数记录资源数目；使用一个进程链表L，链接等待该资源的进程
   - 解决了忙等待问题
   - 在执行wait和signal的时候，操作系统会屏蔽中断，因为这两个系统调用只有几条指令，所以无伤大雅。
   - 如果有多个CPU，为了保证信号量本身的同步，可以使用TSL或者XCHG指令，确保同一时刻只有一个CPU对信号进行操作。

   ```c++
   typedef struct{
   	int value;
   	struct process* L;
   }
   ```

   ```c++
   void wait(semaphore S){
   	S.value--;
   	if(S.value < 0){
   		add this process P to S.L;
   		sleep(P);
   	}
   }
   ```

   ```c++
   void signal(semaphore S){
       S.value++;
       if(S.value <= 0){
           remove a process P from S.L;
           wakeup(P);
       }
   }
   ```

5. 互斥量

   - 没有信号量的计数能力，是信号量的一个简化版本。

   - 仅仅适用于管理共享资源或一小段代码

   - 与`enter_region`代码的区别：不需要忙等待。在用户线程中，没有时钟停止运行时间过长的线程，所以如果用忙等待方法试图获得资源的线程将一直死循环下去。

   - `thread_yield`只是在**用户空间**对线程调度程度程序的一个调用，运算速度快，所以通过mutex_lock用户线程可以在用户空间完成同步。

     ```assembly
     mutex_lock:
     	TSL REGISTER, MUTEX   ;将互斥信号量复制到寄存器，并且将互斥信号量置为1
     	CMP REGISTER, #0
     	JZE ok
     	CALL thread_yield     ;互斥信号量忙，调度另外一个线程.而不是忙等
     	JMP mutex_lock
     ok: RET
     
     mutex_unlock:
     	MOVE MUTEX, #0
     	RET
     ```

6. 生产者-消费者问题（有界缓冲区问题）

   - 对于两个进程，一个是生产者，一个是消费者，共享一个公共的固定大小的缓冲区。当缓冲区满时，生产者在生产，则应当睡眠；当消费者想要从空的缓冲区取东西时，应当睡眠。

     - 使用信号量解决生产者-消费者问题

     ```c++
     // 假定只有一个生产者，一个消费者
     #define N 100
     typedef int semaphore;  //信号量就是一个整数
     semaphore mutex = 1;  //只有一个缓冲区。互斥访问
     semaphore empty = N;
     semaphore full = 0;
     
     void producer(void){
     	int item;
     	while(TRUE){
     		item = produce_item();
     		down(&empty);   //缓冲区空槽位置-1
             down(&mutex);   //进入缓冲区（临界区）
             insert_item(item);
             up(&mutex);
             up(&full);      //缓冲区item数目+1
     	}
     }
     
     void consumer(void){
     	int item;
     	while(TRUE){
     		down(&full);
             down(&mutex);
             item = remove_item();
             up(&mutex);
             up(&empty());
             consume_item(item);
     	}
     }
     ```

7. 管程

   - **使用信号量和互斥量要格外小心**，比如把生产者和消费者的前面两个down交换顺序，即`down(&mutex)`在`down（&empty)`之前：如果生产者进入临界区，并且发现缓冲区已满，则生产者会等待，这个时候消费者无法进入临界区，即没法从缓冲区中取数据。这造成了死锁。
   - 为了更易于编写正确的程序，提出了管程的概念
   - 管程：由过程、变量及数据结构等组成的一个集合，它们组成一个特殊的模块或软件包。
   - 任何时刻管程中只能有一个活跃进程。
   - 由编译器而非程序员来安排互斥，程序员只需要把**所有的临界区转化成管程过程**。

8. 消息传递

   - 使用send和receive原语

     > send(destination, &message);
     >
     > receive(source, &message);

   - 消息的编址方式：（这里的编址方式应该是send和receive发送的地址（destination）和接收的地址(source)）

     - 为每个进程分配一个唯一的地址，让消息按进程的地址编址
     - 引入一种新的数据结构：**信箱**。信箱是用一个对一定数量的消息进行缓冲的地方。当使用信箱时，在send和receive调用中的地址参数就是信箱的地址。信箱也可以被看作一种缓冲区。

   - 使用消息传递解决生产者-消费者问题

     ```c++
     #define N 100
     
     void producer(void){
     	int item;
     	message m;   // 消息缓冲区（消息）
     	
     	while(true){
     		item = produce_item();
     		receive(consumer, &m);    //等待消费者发送空缓冲区（空消息）
     		build_message(&m, item);   //建立一个待发送的消息
     		send(consumer, &m);
     	}
     }
     
     woid consumer(void){
     	int item, i;
     	message m;
     	
     	for(i = 0; i < N; i++)	send(producer, &m);   //先发送N的空消息，即设置缓冲区大小为N
     	while(true){
     		receive(producer, &m);
     		item = extract_item(&m);
     		send(producer, &m);
     		consume_item(item);
     	}
     }
     ```

9. 屏障

   - 用于进程组。在一些应用中，划分了若干阶段，并且规定，除非所有的进程都准备着手进入下一个阶段，否则任何进程都不能进入下一个阶段。
   - 当一个进程到达屏障barrier时，它就被屏障阻拦，知道所有进程都达到该屏障为止。屏障可用于一组进程同步。

10. 总结

    1. 进程同步互斥
       - Peterson算法
       - 硬件方法
         - 中断屏蔽
         - 硬件指令：TSL，XCHG
       - 信号量
       - 管程
    2. 进程通信（狭义上）
       - 管道
         - 匿名管道
         - 命名管道
       - 信号量
       - 消息队列（消息传递）
       - 共享内存
       - 信号
       - 套接字



#### 进程调度

1. 调度时机
   - 创建一个新进程之后，调度算法需要决定运行父进程还是子进程，这可以任意决定。
   - 进程退出时
   - 进程阻塞时
   - I/O中断发生时
2. 非抢占式调度：调度一个进程，让该进程一直运行，直到被阻塞、完成进程退出或者该进程自动释放CPU
3. 抢占式调度：让该进程运行某个固定时段的最大值（需要在时间间隔的末端发生时钟中断）
4. 批处理系统中的调度
   1. 先来先服务
      - 非抢占式，对CPU密集型进程有利。
   2. 最短作业优先
      - 非抢占式，周转时间最优（只有在所有作业都可以同时运行的情形下，最短作业优先算法的周转时间才是最优的）
   3. 最短剩余时间优先
      - 最短作业优先的抢占式版本。
5. 交互式系统中的调度
   1. 轮转调度
      - 所有进程同样重要，每个进程都将被轮流分配一个固定大小的时间片
   2. 优先级调度
      - 每个进程被赋予一个优先级，允许优先级最高的可运行进程先运行。
      - I/O密集型进程应当设置高优先级。
   3. 多级队列
      - 为CPU密集型进程设置较长的时间片比频繁地分给它们很短的时间片要更为高效
      - 高优先级队列中时间片较小，低优先级队列中时间片较大。进程如果在一个时间片结束时没有运行完，就将下降到低优先级队列中。

